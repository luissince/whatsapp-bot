const OpenAI = require('openai');
const axios = require("axios");
const { Message, User, Product } = require('../db/mongodb');

class MessageHandler {
  constructor(whatsAppService) {
    this.whatsAppService = whatsAppService;
    this.catalogoPDFUrl = `${process.env.API_REST_URL}/api/catalogo/documents/pdf/CT0001`;
  }

  async handleIncomingMessage({ messages, type }) {
    try {
      if (type !== "notify" || !messages || !messages[0] || messages[0].key.fromMe) {
        return;
      }

      const message = messages[0];
      const numberWa = message?.key?.remoteJid;
      if (!numberWa) return;

      let captureMessage = null;

      // Procesar texto simple
      if (message.message?.conversation) {
        captureMessage = message.message.conversation;
      } else if (message.message?.extendedTextMessage?.text) {
        captureMessage = message.message.extendedTextMessage.text;
      }
      // Procesar texto de im√°genes o videos
      else if (message.message?.imageMessage?.caption) {
        captureMessage = message.message.imageMessage.caption;
      } else if (message.message?.videoMessage?.caption) {
        captureMessage = message.message.videoMessage.caption;
      }

      // Si el mensaje es un sticker
      if (message.message?.stickerMessage) {
        await this.whatsAppService.sendTextMessage(numberWa, "¬°Bonito sticker! üòÑ ¬øEn qu√© puedo ayudarte hoy? Puedo mostrarte nuestros productos o enviarte nuestro cat√°logo completo.", message);
        return;
      }
      // Si el mensaje es un audio
      else if (message.message?.audioMessage) {
        await this.whatsAppService.sendTextMessage(numberWa, "Recib√≠ tu audio. A√∫n no puedo escucharlos, pero ¬°gracias por enviarlo! üéß ¬øQuieres ver nuestro cat√°logo o buscar alg√∫n producto espec√≠fico?", message);
        return;
      }
      // Si el mensaje es una imagen o video, procesar con su texto si existe
      else if (message.message?.imageMessage || message.message?.videoMessage) {
        const mediaType = message.message?.imageMessage ? "imagen" : "video";
        const caption = message.message?.imageMessage?.caption || message.message?.videoMessage?.caption || `¬°Gracias por tu ${mediaType}!`;

        if (caption && caption.trim() !== "") {
          captureMessage = caption;
        } else {
          await this.whatsAppService.sendTextMessage(numberWa, `¬°Gracias por tu ${mediaType}! ${mediaType === "imagen" ? "üì∏" : "üé•"} ¬øTe gustar√≠a ver nuestro cat√°logo o buscar alg√∫n producto en particular?`, message);
          return;
        }
      }

      if (!captureMessage || typeof captureMessage !== "string" || captureMessage.trim() === "") {
        console.log("No se encontr√≥ texto procesable en el mensaje. Ignorando...");
        return;
      }

      // Si es un texto v√°lido, lo procesamos
      await this._processMessage(captureMessage, numberWa, message);
    } catch (error) {
      console.error("Error handling message:", error);
    }
  }

  // Identifica cuando el usuario selecciona una opci√≥n num√©rica
  _detectarSeleccionNumerica(texto) {
    // Buscar patrones como "1", "2.", "opci√≥n 3", "elegir 4", etc.
    const patrones = [
      /^(\d+)$/i,                   // Solo un n√∫mero
      /^(\d+)[.)]/i,                // N√∫mero seguido de punto o par√©ntesis
      /^(opci√≥n|opcion|elegir|seleccionar|selecci√≥n|seleccion|quiero|me interesa|ver|n√∫mero|numero)\s+(\d+)/i, // Palabra clave + n√∫mero
      /^(el|la|el producto|la opci√≥n|opci√≥n|opcion)\s+(\d+)/i,  // Art√≠culo + n√∫mero
    ];

    for (const patron of patrones) {
      const match = texto.trim().match(patron);
      if (match) {
        // Extraer el n√∫mero, que puede estar en diferentes grupos seg√∫n el patr√≥n
        const numero = parseInt(match[1].match(/\d+/) ? match[1] : match[2]);
        if (!isNaN(numero)) return numero;
      }
    }

    return null;
  }

  // Detecta si el usuario quiere comprar algo
  _detectarIntencionCompra(texto) {
    const patrones = [
      /cu√°nto cuesta/i,
      /precio/i,
      /cotizaci√≥n/i,
      /quiero comprar/i,
      /puedo pagar/i,
      /tienes/i,
      /cu√°nto vale/i,
      /disponible/i,
      /venden/i,
      /tienen/i,
      /comprar/i,
      /adquirir/i,
      /buscar/i,
      /busco/i,
      /necesito/i,
      /productos/i,
      /ver producto/i,
      /mostrar productos/i
    ];
    return patrones.some((p) => p.test(texto));
  }

  // Identifica si el usuario pide un cat√°logo
  _detectarPeticionCatalogo(texto) {
    const patrones = [
      /cat√°logo/i,
      /catalogo/i,
      /productos/i,
      /listado/i,
      /tienen m√°s/i,
      /qu√© m√°s tienen/i,
      /qu√© tienen/i,
      /lista/i,
      /mostrar/i,
      /ver m√°s/i,
      /ver todo/i,
      /ver opciones/i
    ];
    return patrones.some((p) => p.test(texto));
  }

  _detectarAceptacionCatalogo(texto) {
    const patrones = [
      /si\b/i,
      /claro/i,
      /por supuesto/i,
      /s√≠/i,
      /ok/i,
      /okay/i,
      /dale/i,
      /adelante/i,
      /env√≠a/i,
      /envia/i,
      /manda/i,
      /bueno/i,
      /bien/i,
      /quiero/i,
      /me gustar√≠a/i,
      /env√≠ame/i,
      /enviame/i,
      /^1$/i,      // Solo el n√∫mero 1 (asumiendo que 1 = cat√°logo)
      /^cat√°logo$/i,
      /^catalogo$/i
    ];
    return patrones.some((p) => p.test(texto));
  }

  // Reconoce saludos
  _detectarSaludo(texto) {
    const saludos = [
      /hola/i,
      /buenos d√≠as/i,
      /buenas tardes/i,
      /buenas noches/i,
      /qu√© tal/i,
      /saludos/i,
      /hey/i,
      /ola/i,
      /hi/i,
      /hello/i
    ];
    return saludos.some(s => s.test(texto));
  }

  _detectarBusquedaNueva(texto) {
    const patrones = [
      /otros productos/i,
      /buscar otro/i,
      /otra cosa/i,
      /otro producto/i,
      /buscar m√°s/i,
      /buscar mas/i,
      /buscar de nuevo/i,
      /nueva b√∫squeda/i,
      /nueva busqueda/i,
      /otro art√≠culo/i,
      /otro articulo/i,
      /regresar/i,
      /volver/i,
      /men√∫/i,
      /menu/i,
      /buscar algo m√°s/i,
      /buscar algo mas/i,
      /cambiar producto/i
    ];
    return patrones.some((p) => p.test(texto));
  }

  _detectarMasInformacion(texto) {
    const patrones = [
      /m√°s informaci√≥n/i,
      /mas informacion/i,
      /detalles/i,
      /especificaciones/i,
      /caracter√≠sticas/i,
      /caracteristicas/i,
      /dime m√°s/i,
      /m√°s sobre/i,
      /expl√≠came/i,
      /explicame/i,
      /cu√©ntame/i,
      /cuentame/i,
      /saber m√°s/i,
      /informaci√≥n detallada/i,
      /informaci√≥n completa/i
    ];
    return patrones.some((p) => p.test(texto));
  }

  // Verifica si el mensaje est√° relacionado con el negocio
  _detectarTemaNegocio(texto) {
    // Patrones que indican que el tema est√° relacionado con el negocio
    const patrones = [
      // T√©rminos de productos/servicios
      /producto/i, /servicio/i, /art√≠culo/i, /articulo/i, /item/i,
      /cat√°logo/i, /catalogo/i, /inventario/i, /stock/i, /disponibilidad/i,

      // T√©rminos de compra
      /comprar/i, /adquirir/i, /precio/i, /costo/i, /valor/i,
      /cotizaci√≥n/i, /cotizacion/i, /oferta/i, /promoci√≥n/i, /promocion/i,
      /descuento/i, /pago/i, /efectivo/i, /tarjeta/i, /transferencia/i,

      // T√©rminos de entrega/log√≠stica
      /env√≠o/i, /envio/i, /entrega/i, /despacho/i, /recojo/i, /delivery/i,
      /tiempo/i, /plazo/i, /direcci√≥n/i, /direccion/i, /ubicaci√≥n/i, /ubicacion/i,

      // T√©rminos de atenci√≥n/consulta
      /atender/i, /atenci√≥n/i, /atencion/i, /consulta/i, /duda/i,
      /preguntar/i, /informar/i, /informaci√≥n/i, /informacion/i,
      /horario/i, /tienda/i, /local/i, /tiendas/i,

      // T√©rminos de negocios
      /negocio/i, /empresa/i, /venta/i, /comercio/i, /tienda/i,
      /vendedor/i, /cliente/i, /comprador/i, /proveedor/i,

      // Categor√≠as espec√≠ficas (personalizar seg√∫n el negocio)
      /ropa/i, /tecnolog√≠a/i, /tecnologia/i, /electr√≥nico/i, /electronico/i,
      /computadora/i, /laptop/i, /celular/i, /tel√©fono/i, /telefono/i
    ];

    return patrones.some((p) => p.test(texto));
  }

  async _guardarHistorial(sender, role, content) {
    try {
      // 1. Guardar el mensaje en la colecci√≥n de mensajes
      await Message.create({
        whatsappId: sender,
        role: role,
        content: content
      });

      // 2. Actualizar informaci√≥n del usuario
      const userData = {
        lastInteraction: new Date()
      };

      if (role === 'user') {
        // Solo actualizar estos campos cuando es un mensaje del usuario
        await User.findOneAndUpdate(
          { whatsappId: sender },
          {
            $set: userData
          },
          { upsert: true, new: true }
        );
      }

      console.log(`‚úÖ Mensaje guardado en MongoDB: ${sender} (${role})`);
    } catch (error) {
      console.error('‚ùå Error al guardar mensaje en MongoDB:', error);
    }
  }

  async _obtenerHistorial(sender, limit = 10) {
    try {
      // Buscar los √∫ltimos 'limit' mensajes del usuario
      const mensajes = await Message.find({ whatsappId: sender })
        .sort({ timestamp: -1 })
        .limit(limit)
        .lean();

      // Invertir orden para tener cronolog√≠a correcta
      return mensajes.reverse();
    } catch (error) {
      console.error('‚ùå Error al obtener historial de MongoDB:', error);
      return [];
    }
  }

  async _obtenerUsuario(sender) {
    try {
      let usuario = await User.findOne({ whatsappId: sender });

      if (!usuario) {
        usuario = await User.create({
          whatsappId: sender,
          etapaConversacion: 'inicial',
          ofrecidoCatalogo: false,
          esperandoRespuestaCatalogo: false,
          esperandoSeleccionProducto: false
        });
        console.log(`‚úÖ Nuevo usuario creado en MongoDB: ${sender}`);
      }

      return usuario;
    } catch (error) {
      console.error('‚ùå Error al obtener/crear usuario en MongoDB:', error);
      // Devolver un objeto por defecto para no romper el flujo
      return {
        whatsappId: sender,
        etapaConversacion: 'inicial',
        ofrecidoCatalogo: false,
        esperandoRespuestaCatalogo: false,
        esperandoSeleccionProducto: false,
        productosConsultados: []
      };
    }
  }

  async _actualizarUsuario(sender, datos) {
    try {
      await User.findOneAndUpdate(
        { whatsappId: sender },
        { $set: datos },
        { upsert: true }
      );
      console.log(`‚úÖ Usuario actualizado en MongoDB: ${sender}`);
    } catch (error) {
      console.error('‚ùå Error al actualizar usuario en MongoDB:', error);
    }
  }

  async _registrarProductoConsultado(sender, producto) {
    try {
      await User.findOneAndUpdate(
        { whatsappId: sender },
        {
          $push: {
            productosConsultados: {
              productoId: producto.idProducto,
              nombre: producto.nombre,
              fecha: new Date()
            }
          }
        }
      );
      console.log(`‚úÖ Producto registrado para usuario ${sender}: ${producto.nombre}`);
    } catch (error) {
      console.error('‚ùå Error al registrar producto consultado:', error);
    }
  }

  async _enviarCatalogo(sender, originalMessage) {
    try {
      // Actualizar estado del usuario
      await this._actualizarUsuario(sender, {
        esperandoRespuestaCatalogo: false,
        ofrecidoCatalogo: true
      });

      // Enviar mensaje sobre el cat√°logo
      const mensajeCatalogo = "¬°Excelente! Aqu√≠ te comparto nuestro cat√°logo completo de productos. Puedes revisarlo y si necesitas informaci√≥n sobre alg√∫n producto espec√≠fico, no dudes en preguntarme. üìö";
      await this.whatsAppService.sendTextMessage(sender, mensajeCatalogo, originalMessage);

      // Enviar el PDF del cat√°logo
      try {
        await this.whatsAppService.sendDocumentMessage(
          sender,
          this.catalogoPDFUrl,
          originalMessage,
          "Cat√°logo_Productos.pdf",
          "Cat√°logo completo de productos"
        );
        await this._guardarHistorial(sender, 'assistant', mensajeCatalogo + " [Se envi√≥ el cat√°logo PDF]");
      } catch (pdfError) {
        console.error("Error al enviar el cat√°logo PDF:", pdfError);
        await this.whatsAppService.sendTextMessage(
          sender,
          "Lo siento, tuve problemas para enviar el cat√°logo. Puedes descargarlo directamente desde este enlace: " + this.catalogoPDFUrl,
          originalMessage
        );
        await this._guardarHistorial(sender, 'assistant', "Lo siento, tuve problemas para enviar el cat√°logo. Puedes descargarlo directamente desde este enlace: " + this.catalogoPDFUrl);
      }
    } catch (error) {
      console.error("Error al enviar cat√°logo:", error);
    }
  }

  async _mostrarMenuInicial(sender, originalMessage) {
    const mensajeMenu = `
    ¬°Hola! üëã Soy el asistente de la tienda. ¬øEn qu√© puedo ayudarte hoy?

    1Ô∏è‚É£ Ver cat√°logo completo üìö
    2Ô∏è‚É£ Buscar un producto espec√≠fico üîç
    3Ô∏è‚É£ Consultar disponibilidad üì¶
    4Ô∏è‚É£ Informaci√≥n de env√≠os üöö
    5Ô∏è‚É£ Contactar con un vendedor üë®‚Äçüíº

    Puedes elegir una opci√≥n escribiendo el n√∫mero o hacerme cualquier pregunta directamente.`;

    await this.whatsAppService.sendTextMessage(sender, mensajeMenu.trim(), originalMessage);
    await this._guardarHistorial(sender, 'assistant', mensajeMenu.trim());
    await this._actualizarUsuario(sender, { etapaConversacion: 'menu_inicial' });
  }

  async _mostrarOpcionesDespuesDeProducto(sender, originalMessage) {
    const mensajeOpciones = `¬øQu√© te gustar√≠a hacer ahora?

    1Ô∏è‚É£ Ver m√°s detalles de este producto
    2Ô∏è‚É£ Buscar otro producto 
    3Ô∏è‚É£ Ver cat√°logo completo
    4Ô∏è‚É£ Contactar con un vendedor para comprar

    Por favor, indica el n√∫mero de la opci√≥n que prefieres o escribe tu consulta.`;

    await this.whatsAppService.sendTextMessage(sender, mensajeOpciones, originalMessage);
    await this._guardarHistorial(sender, 'assistant', mensajeOpciones);
  }

  async _buscarProductosYMostrarLista(termino, sender, originalMessage) {
    try {
      const url = `${process.env.API_REST_URL}/api/producto/list?opcion=1&buscar=${encodeURIComponent(termino)}&posicionPagina=0&filasPorPagina=10`;
      const response = await axios.get(url);
      const productos = response.data.result || [];

      if (productos.length === 0) {
        await this.whatsAppService.sendTextMessage(
          sender,
          `No encontr√© productos que coincidan con "${termino}". ¬øPodr√≠as intentar con otra b√∫squeda o ver nuestro cat√°logo completo?`,
          originalMessage
        );
        await this._guardarHistorial(sender, 'assistant', `No encontr√© productos que coincidan con "${termino}". ¬øPodr√≠as intentar con otra b√∫squeda o ver nuestro cat√°logo completo?`);
        return [];
      }

      // Guardar resultados para uso futuro cuando seleccionen por n√∫mero
      const newProducts = productos.map(p => {
        return {
          whatsappId: sender,
          ...p
        }
      });

      await Product.deleteMany({ whatsappId: sender });
      await Product.insertMany(newProducts);

      // Crear lista numerada de productos
      let mensajeLista = `Encontr√© ${productos.length} producto${productos.length > 1 ? 's' : ''} que coinciden con tu b√∫squeda:\n\n`;

      productos.forEach((producto, index) => {
        mensajeLista += `${index + 1}Ô∏è‚É£ *${producto.nombre}*\n`;
        mensajeLista += `   üí∞ Precio: S/ ${producto.precio}\n`;
        mensajeLista += `   üìã C√≥digo: ${producto.codigo}\n\n`;
      });

      mensajeLista += "Para ver m√°s detalles de un producto, escribe el n√∫mero correspondiente. O si prefieres, puedes hacer una nueva b√∫squeda.";

      await this.whatsAppService.sendTextMessage(sender, mensajeLista, originalMessage);
      await this._guardarHistorial(sender, 'assistant', mensajeLista);

      // Actualizar estado del usuario
      await this._actualizarUsuario(sender, {
        etapaConversacion: 'mostrando_resultados',
        esperandoSeleccionProducto: true
      });

      return productos;
    } catch (error) {
      console.error("Error al buscar productos:", error);
      await this.whatsAppService.sendTextMessage(
        sender,
        "Lo siento, tuve un problema al buscar productos. ¬øPodr√≠as intentarlo nuevamente?",
        originalMessage
      );
      await this._guardarHistorial(sender, 'assistant', "Lo siento, tuve un problema al buscar productos. ¬øPodr√≠as intentarlo nuevamente?");
      return [];
    }
  }

  async _obtenerDetallesProducto(idProducto, sender, originalMessage) {
    try {
      const url = `${process.env.API_REST_URL}/api/producto/id?idProducto=${idProducto}`;
      const response = await axios.get(url);
      const producto = response.data;

      if (!producto) {
        await this.whatsAppService.sendTextMessage(
          sender,
          "Lo siento, no pude obtener detalles de este producto. ¬øQuieres ver otros productos?",
          originalMessage
        );
        return null;
      }

      // Registrar el producto consultado
      await this._registrarProductoConsultado(sender, producto);

      // Construir mensaje detallado del producto
      let mensajeDetalle = `*${producto.nombre}*\n\n`;
      mensajeDetalle += `üí∞ *Precio:* S/ ${producto.precio}\n`;
      mensajeDetalle += `üìã *C√≥digo:* ${producto.codigo}\n`;
      mensajeDetalle += `üìã *Sku:* ${producto.sku}\n`;
      // mensajeDetalle += `üè∑Ô∏è *Categor√≠a:* ${producto.categoria}\n`;

      // if (producto.marca) {
      //   mensajeDetalle += `üîñ *Marca:* ${producto.marca}\n`;
      // }

      // if (producto.descripcion) {
      //   mensajeDetalle += `\nüìù *Descripci√≥n:*\n${producto.descripcion}\n`;
      // }

      // mensajeDetalle += `\nüì¶ *Stock disponible:* ${producto.stock} unidades\n`;

      // if (producto.observacion) {
      //   mensajeDetalle += `\nüìå *Observaciones:*\n${producto.observacion}\n`;
      // }

      mensajeDetalle += `\nSi est√°s interesado en comprar este producto, puedo contactarte con un vendedor inmediatamente.`;

      await this.whatsAppService.sendTextMessage(sender, mensajeDetalle, originalMessage);
      await this._guardarHistorial(sender, 'assistant', mensajeDetalle);

      // Enviar imagen si est√° disponible
      if (producto.imagen) {
        try {
          await this.whatsAppService.sendImageMessage(sender, producto.imagen.url, originalMessage);
        } catch (imgError) {
          console.error("Error al enviar imagen:", imgError.message);
        }
      }

      // Mostrar opciones despu√©s de mostrar el producto
      await this._mostrarOpcionesDespuesDeProducto(sender, originalMessage);

      // Actualizar etapa
      await this._actualizarUsuario(sender, {
        etapaConversacion: 'mostrando_producto',
        productoActual: idProducto
      });

      // Notificar al due√±o del inter√©s en este producto
      const mensajeDue√±o = `
      üì¢ *Cliente interesado en producto*
      üë§ *Cliente:* ${originalMessage.pushName || "Cliente"}
      üì± *N√∫mero:* ${sender.split('@')[0]}
      üõçÔ∏è *Producto:* ${producto.nombre}
      üí∞ *Precio:* S/ ${producto.precio}
      üìã *C√≥digo:* ${producto.codigo}
      `;
      const numeroDelDue√±o = `${process.env.OWNER_NUMBER}@c.us`;
      await this.whatsAppService.sendTextMessage(numeroDelDue√±o, mensajeDue√±o);

      return producto;
    } catch (error) {
      console.error("Error al obtener detalles del producto:", error);
      await this.whatsAppService.sendTextMessage(
        sender,
        "Lo siento, no pude obtener los detalles de este producto en este momento. ¬øQuieres ver otros productos?",
        originalMessage
      );
      await this._guardarHistorial(sender, 'assistant', "Lo siento, no pude obtener los detalles de este producto en este momento. ¬øQuieres ver otros productos?");
      return null;
    }
  }

  async _processMessage(text, sender, originalMessage) {
    try {
      const cleanText = text.trim().replace(/\s+/g, ' ');

      // 1. Guardar mensaje del cliente en el historial
      await this._guardarHistorial(sender, 'user', cleanText);

      // 2. Obtener informaci√≥n del usuario desde MongoDB
      const usuario = await this._obtenerUsuario(sender);

      // 3. Verificar si el mensaje es una selecci√≥n num√©rica de un producto
      const numeroSeleccionado = this._detectarSeleccionNumerica(cleanText);
      const etapaActual = usuario.etapaConversacion || 'inicial';

      if (process.env.TYPE === "business") {
        await this._processBusinessMessaage(cleanText, usuario, etapaActual, numeroSeleccionado, sender, originalMessage);
      } else {
        await this._processPersonalMessage(cleanText, sender, originalMessage);
      }

    } catch (error) {
      console.error("Error en processMessage:", error);
      await this.whatsAppService.sendTextMessage(sender, "Lo siento, tuve un problema t√©cnico. ¬øPodr√≠as intentarlo nuevamente?", originalMessage);
    }
  }

  async _processBusinessMessaage(cleanText, usuario, etapaActual, numeroSeleccionado, sender, originalMessage) {
    // CASO ESPECIAL: Si est√° esperando selecci√≥n de un producto por n√∫mero
    if (usuario.esperandoSeleccionProducto && numeroSeleccionado !== null) {
      const ok = await this._processSpecialCase(numeroSeleccionado, sender, originalMessage);
      if (ok) return;
    }

    // CASO INICIAL: Si es un nuevo usuario o es un saludo
    if (etapaActual === 'inicial' || this._detectarSaludo(cleanText)) {
      await this._processInitialCase(sender, originalMessage, originalMessage);
      return;
    }

    // CASO MENU: Si el usuario responde al men√∫ inicial con una opci√≥n num√©rica
    if (etapaActual === 'menu_inicial' && numeroSeleccionado !== null) {
      await this._processSelectMenuCase(numeroSeleccionado, sender, originalMessage);
      return;
    }

    // CASO OPCIONES DESPU√âS DE PRODUCTO: Si el usuario responde despu√©s de ver un producto
    if (etapaActual === 'mostrando_producto' && numeroSeleccionado !== null) {
      this._processSelectProductCase(numeroSeleccionado, sender, originalMessage);
      return;
    }

    // CASO PETICI√ìN DE CAT√ÅLOGO: El usuario pide o acepta ver el cat√°logo
    const pideCatalogo = this._detectarPeticionCatalogo(cleanText);
    const aceptaCatalogo = this._detectarAceptacionCatalogo(cleanText);
    const esperandoRespuestaCatalogo = usuario.esperandoRespuestaCatalogo;

    if (pideCatalogo || (esperandoRespuestaCatalogo && aceptaCatalogo)) {
      await this._enviarCatalogo(sender, originalMessage);
      return;
    }

    // CASO ESPERANDO B√öSQUEDA: El usuario est√° buscando un producto espec√≠fico
    if (etapaActual === 'esperando_busqueda' || this._detectarIntencionCompra(cleanText)) {
      this._processSearchProductCase(cleanText, sender, originalMessage);
      return;
    }

    // CASO NUEVA B√öSQUEDA: El usuario quiere buscar algo nuevo
    if (this._detectarBusquedaNueva(cleanText)) {
      await this.whatsAppService.sendTextMessage(
        sender,
        "¬°Claro! ¬øQu√© producto te gustar√≠a buscar ahora? Por favor, ind√≠came el nombre o tipo de producto que te interesa.",
        originalMessage
      );
      await this._guardarHistorial(sender, 'assistant', "¬°Claro! ¬øQu√© producto te gustar√≠a buscar ahora? Por favor, ind√≠came el nombre o tipo de producto que te interesa.");
      await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
      return;
    }

    // CASO MOSTRAR MEN√ö: El usuario quiere ver opciones o men√∫
    if (cleanText.toLowerCase().includes("menu") ||
      cleanText.toLowerCase().includes("men√∫") ||
      cleanText.toLowerCase().includes("opciones") ||
      cleanText.toLowerCase().includes("ayuda")) {
      await this._mostrarMenuInicial(sender, originalMessage);
      return;
    }

    // CASO DEFAULT: Procesamiento con AI para otros mensajes
    // Verificar primero si el tema est√° relacionado con el negocio
    const esTemaNegocio = this._detectarTemaNegocio(cleanText);

    if (!esTemaNegocio) {
      const mensajeFueraContexto = "Disculpa, solo puedo ayudarte con temas relacionados a nuestros productos y servicios. ¬øHay algo espec√≠fico sobre nuestros productos que te gustar√≠a saber? Puedo mostrarte el cat√°logo o buscar un producto espec√≠fico para ti.";
      await this.whatsAppService.sendTextMessage(sender, mensajeFueraContexto, originalMessage);
      await this._guardarHistorial(sender, 'assistant', mensajeFueraContexto);

      // Mostrar men√∫ para redirigir la conversaci√≥n
      setTimeout(async () => {
        await this._mostrarMenuInicial(sender, originalMessage);
      }, 1000);
      return;
    }

    // Procesar con IA para casos no cubiertos, pero relacionados con el negocio
    await this._processIA(cleanText, sender, etapaActual, originalMessage);
  }

  async _processPersonalMessage(cleanText, sender, originalMessage) {
    // Process with OpenAI using a different system prompt for personal/professional context
    const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const systemPrompt = `
      Eres un asistente personal para un profesional en ingenier√≠a.
      Responde preguntas sobre su trayectoria profesional, habilidades, proyectos y experiencia en ingenier√≠a.

      Informaci√≥n clave sobre el profesional:
      Nombre: Luis Alexander (aAnderls)

      Profesi√≥n: Ingeniero de Sistemas

      Experiencia: 5 a√±os

      Habilidades principales: Programaci√≥n, Bases de Datos, Redes, Seguridad y Computaci√≥n en la Nube

      Intereses personales:
      Adem√°s de ser un apasionado de la tecnolog√≠a, Luis tiene una vida llena de peque√±as grandes pasiones: le encanta hornear panes artesanales (en especial bomboloni y brioche), correr al aire libre y cuidar con amor a sus pollitos, que viven felices en un lugar verde y comen mejor que muchos humanos.

      Promueve una vida sostenible, evita el uso de pl√°sticos siempre que puede y siente verdadera curiosidad por el mundo de las ventas. En sus ratos libres, desarrolla videojuegos, donde combina su lado l√≥gico con el creativo.

      Y, por supuesto, no se puede hablar de Luis sin mencionar su amor por el caf√© (y la leche con caf√©). Las ma√±anas sin eso simplemente no son ma√±anas.

      Estilo de interacci√≥n:
      Aunque el enfoque es profesional, Luis tambi√©n es cercano y aut√©ntico. Si le hacen preguntas demasiado personales o fuera de lugar, responder√° con humor de adulto, iron√≠a suave y ese toque relajado que da la experiencia (y quiz√° un poco de pan casero en el horno).

      Mant√©n las respuestas claras, confiables y con un toque humano. Si el tema se sale del √°mbito profesional, responde con simpat√≠a y, cuando sea necesario, redirige con elegancia hacia lo que realmente importa‚Ä¶ aunque siempre con buena onda.
    `;

    const historialUsuario = await this._obtenerHistorial(sender);
    const mensajesHistorial = historialUsuario.map(m => ({
      role: m.role,
      content: m.content
    }));

    const completion = await client.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        ...mensajesHistorial,
        { role: "user", content: cleanText }
      ],
      max_tokens: 500,
      temperature: 0.7,
    });

    const respuestaAI = completion.choices[0].message.content;

    // Save bot response to history
    await this._guardarHistorial(sender, 'assistant', respuestaAI);

    // Send text response
    await this.whatsAppService.sendTextMessage(sender, respuestaAI, originalMessage);
  }

  async _processInitialCase(sender, originalMessage) {
    await this._mostrarMenuInicial(sender, originalMessage);
  }

  async _processSelectMenuCase(numeroSeleccionado, sender, originalMessage) {
    switch (numeroSeleccionado) {
      case 1: // Ver cat√°logo completo
        await this._enviarCatalogo(sender, originalMessage);
        break;
      case 2: // Buscar producto espec√≠fico
        await this.whatsAppService.sendTextMessage(
          sender,
          "¬°Perfecto! ¬øQu√© producto est√°s buscando? Por favor, ind√≠came el nombre o tipo de producto que te interesa.",
          originalMessage
        );
        await this._guardarHistorial(sender, 'assistant', "¬°Perfecto! ¬øQu√© producto est√°s buscando? Por favor, ind√≠came el nombre o tipo de producto que te interesa.");
        await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
        break;
      case 3: // Consultar disponibilidad
        await this.whatsAppService.sendTextMessage(
          sender,
          "Para consultar disponibilidad, necesito saber qu√© producto te interesa. ¬øPodr√≠as indicarme cu√°l es el producto que buscas?",
          originalMessage
        );
        await this._guardarHistorial(sender, 'assistant', "Para consultar disponibilidad, necesito saber qu√© producto te interesa. ¬øPodr√≠as indicarme cu√°l es el producto que buscas?");
        await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
        break;
      case 4: // Info de env√≠os
        const mensajeEnvios = `*Informaci√≥n sobre env√≠os* üöö

        Realizamos env√≠os a nivel nacional:

        ‚úÖ Lima Metropolitana: Entrega en 24-48 horas (S/15)
        ‚úÖ Provincias: Entrega en 3-5 d√≠as h√°biles (var√≠a seg√∫n destino)
        ‚úÖ Env√≠o gratis: En compras mayores a S/200 en Lima

        Para coordinar un env√≠o, necesitamos:
        - Nombre completo
        - Direcci√≥n exacta
        - Tel√©fono de contacto
        - Referencia del domicilio

        ¬øNecesitas cotizar el env√≠o para alg√∫n producto espec√≠fico?`;
        await this.whatsAppService.sendTextMessage(sender, mensajeEnvios, originalMessage);
        await this._guardarHistorial(sender, 'assistant', mensajeEnvios);
        await this._actualizarUsuario(sender, { etapaConversacion: 'informacion_envios' });
        break;
      case 5: // Contactar vendedor
        const mensajeContacto = `
        En breve uno de nuestros vendedores se pondr√° en contacto contigo. 

        Mientras tanto, ¬øhay alg√∫n producto espec√≠fico que te interese? Puedo mostrarte detalles para que tengas m√°s informaci√≥n.`;
        await this.whatsAppService.sendTextMessage(sender, mensajeContacto, originalMessage);
        await this._guardarHistorial(sender, 'assistant', mensajeContacto);

        // Notificar al due√±o/vendedor
        const numeroDelDue√±o = `${process.env.OWNER_NUMBER}@c.us`;
        const mensajeDue√±o = `
        üì¢ *Cliente solicit√≥ contacto con vendedor*
        üë§ *Nombre:* ${originalMessage.pushName || "Cliente"}
        üì± *N√∫mero:* ${sender.split('@')[0]}
        ‚è∞ *Fecha/Hora:* ${new Date().toLocaleString()}
        `;
        await this.whatsAppService.sendTextMessage(numeroDelDue√±o, mensajeDue√±o);

        await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_vendedor' });
        break;
      default:
        await this._mostrarMenuInicial(sender, originalMessage);
    }
  }

  async _processSelectProductCase(numeroSeleccionado, sender, originalMessage) {
    switch (numeroSeleccionado) {
      case 1: // Ver m√°s detalles del producto actual
        if (usuario.productoActual) {
          await this._obtenerDetallesProducto(usuario.productoActual, sender, originalMessage);
        } else {
          await this.whatsAppService.sendTextMessage(
            sender,
            "Lo siento, parece que no tengo el registro del producto que estabas viendo. ¬øPodr√≠as buscar nuevamente?",
            originalMessage
          );
          await this._guardarHistorial(sender, 'assistant', "Lo siento, parece que no tengo el registro del producto que estabas viendo. ¬øPodr√≠as buscar nuevamente?");
          await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
        }
        break;
      case 2: // Buscar otro producto
        await this.whatsAppService.sendTextMessage(
          sender,
          "¬°Perfecto! ¬øQu√© otro producto te gustar√≠a buscar? Por favor, ind√≠came el nombre o tipo de producto.",
          originalMessage
        );
        await this._guardarHistorial(sender, 'assistant', "¬°Perfecto! ¬øQu√© otro producto te gustar√≠a buscar? Por favor, ind√≠came el nombre o tipo de producto.");
        await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
        break;
      case 3: // Ver cat√°logo completo
        await this._enviarCatalogo(sender, originalMessage);
        break;
      case 4: // Contactar vendedor para comprar
        const mensajeCompraNuevo = `
        ¬°Excelente elecci√≥n! En breve uno de nuestros vendedores se pondr√° en contacto para ayudarte con la compra del producto. Mientras tanto, ¬øhay algo m√°s en lo que pueda ayudarte?`;
        await this.whatsAppService.sendTextMessage(sender, mensajeCompraNuevo, originalMessage);
        await this._guardarHistorial(sender, 'assistant', mensajeCompraNuevo);

        // Notificar al due√±o/vendedor sobre inter√©s de compra
        const numDue√±o = process.env.OWNER_NUMBER || "51931341082@c.us";
        const productoId = usuario.productoActual;
        let nombreProducto = "producto consultado";

        // Intentar obtener nombre del producto
        const productos = await Product.find({ whatsappId: sender });
        if (productos) {
          const productoEncontrado = productos.find(p => p.idProducto === productoId);
          if (productoEncontrado) {
            nombreProducto = productoEncontrado.nombre;
          }
        }

        const mensajeInteresCompra = `
        üîî *INTER√âS DE COMPRA* üîî
        üë§ *Cliente:* ${originalMessage.pushName || "Cliente"}
        üì± *N√∫mero:* ${sender.split('@')[0]}
        üõí *Producto:* ${nombreProducto}
        üÜî *ID Producto:* ${productoId || "No disponible"}
        ‚è∞ *Fecha/Hora:* ${new Date().toLocaleString()}
        
        ‚úÖ El cliente est√° interesado en comprar y espera ser contactado. Por favor, comun√≠cate a la brevedad.
        `;
        await this.whatsAppService.sendTextMessage(numDue√±o, mensajeInteresCompra);

        await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_vendedor' });
        break;
      default:
        await this._mostrarOpcionesDespuesDeProducto(sender, originalMessage);
    }
  }

  async _processSearchProductCase(cleanText, sender, originalMessage) {
    // 1. Extraemos el nombre del producto desde el mensaje
    const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const extractPrompt = `
    Extrae solamente el nombre del producto del siguiente mensaje. Devu√©lvelo sin ninguna palabra adicional. Si no hay producto, responde "ninguno".
    Mensaje: "${cleanText}"
    `;

    const extractCompletion = await client.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: "Eres un extractor de nombres de producto desde mensajes de clientes." },
        { role: "user", content: extractPrompt }
      ],
      temperature: 0,
      max_tokens: 50,
    });

    const productoBuscado = extractCompletion.choices[0].message.content.trim();

    if (productoBuscado.toLowerCase() === "ninguno") {
      // No se identific√≥ un producto espec√≠fico
      await this.whatsAppService.sendTextMessage(
        sender,
        "Parece que est√°s buscando un producto, pero no logro identificar cu√°l. ¬øPodr√≠as detallar m√°s qu√© producto est√°s buscando?",
        originalMessage
      );
      await this._guardarHistorial(sender, 'assistant', "Parece que est√°s buscando un producto, pero no logro identificar cu√°l. ¬øPodr√≠as detallar m√°s qu√© producto est√°s buscando?");
      await this._actualizarUsuario(sender, { etapaConversacion: 'esperando_busqueda' });
    } else {
      // Se identific√≥ un producto, buscar y mostrar lista
      await this._buscarProductosYMostrarLista(productoBuscado, sender, originalMessage);
    }
  }

  async _processSpecialCase(numeroSeleccionado, sender, originalMessage) {
    // Verificar que hay resultados guardados y que el n√∫mero es v√°lido
    const products = await Product.find({ whatsappId: sender });
    const resultadosActuales = products || [];

    if (resultadosActuales.length >= numeroSeleccionado && numeroSeleccionado > 0) {
      const productoSeleccionado = resultadosActuales[numeroSeleccionado - 1];
      await this._actualizarUsuario(sender, { esperandoSeleccionProducto: false });

      if (productoSeleccionado && productoSeleccionado.idProducto) {
        // Buscar detalles completos del producto
        await this._obtenerDetallesProducto(productoSeleccionado.idProducto, sender, originalMessage);
        return true;
      }
    } else {
      await this.whatsAppService.sendTextMessage(
        sender,
        `Por favor selecciona un n√∫mero v√°lido entre 1 y ${resultadosActuales.length}, o busca otro producto.`,
        originalMessage
      );
      await this._guardarHistorial(sender, 'assistant', `Por favor selecciona un n√∫mero v√°lido entre 1 y ${resultadosActuales.length}, o busca otro producto.`);
      return true;
    }

    return false;
  }

  async _processIA(cleanText, sender, etapaActual, originalMessage) {
    const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    // Obtener historial para dar contexto a la AI
    const historialUsuario = await this._obtenerHistorial(sender, 6);
    const mensajesHistorial = historialUsuario.map(m => ({
      role: m.role,
      content: m.content
    }));

    const systemPrompt = `
      Eres un asistente virtual amable para una tienda online. Da respuestas breves, amables y claras, enfocadas en el negocio.
      
      Tienes las siguientes funciones principales:
      1. Ayudar a buscar productos
      2. Informar sobre precios y disponibilidad
      3. Compartir cat√°logos
      4. Informar sobre env√≠os y formas de pago
      
      Tu objetivo es mantener al cliente interesado y eventualmente guiarlo hacia ver productos espec√≠ficos, solicitar el cat√°logo o contactar con un vendedor.
      
      No respondas a temas personales o no relacionados con la tienda.
      
      El cliente debe ser guiado a seguir las opciones del men√∫:
      - Ver cat√°logo completo
      - Buscar un producto espec√≠fico
      - Consultar disponibilidad
      - Informaci√≥n de env√≠os
      - Contactar con un vendedor
      `;

    const completion = await client.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        ...mensajesHistorial,
        { role: "user", content: cleanText }
      ],
      max_tokens: 250,
      temperature: 0.7,
    });

    const respuestaAI = completion.choices[0].message.content;

    // Guardar respuesta del bot en el historial
    await this._guardarHistorial(sender, 'assistant', respuestaAI);

    // Enviar respuesta de texto
    await this.whatsAppService.sendTextMessage(sender, respuestaAI, originalMessage);

    // Si llevamos varias interacciones y no estamos en un flujo espec√≠fico, mostrar men√∫ de nuevo
    const interaccionesTotal = historialUsuario.length;
    if (interaccionesTotal > 10 && etapaActual === 'conversando') {
      setTimeout(async () => {
        await this._mostrarMenuInicial(sender, originalMessage);
      }, 2000);
    }

  }

}

module.exports = { MessageHandler };